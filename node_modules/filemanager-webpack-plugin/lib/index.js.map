{"version":3,"file":"index.js","sources":["../src/actions/copy.js","../src/actions/move.js","../src/actions/delete.js","../src/actions/mkdir.js","../src/actions/archive.js","../src/index.js"],"sourcesContent":["const fs = require('fs');\nconst path = require('path');\nconst cpx = require('cpx');\nconst fsExtra = require('fs-extra');\nconst makeDir = require('make-dir');\n\n/**\n * Execute copy action\n *\n * @param {Object} command - Command data for given action\n * @return {Function|null} - Function that returns a promise or null\n */\nfunction copyAction(command, options) {\n  const { verbose } = options;\n\n  if (!command.source || !command.destination) {\n    if (verbose) {\n      console.log(\n        '  - FileManagerPlugin: Warning - copy parameter has to be formated as follows: { source: <string>, destination: <string> }',\n      );\n    }\n    return null;\n  }\n\n  return () =>\n    new Promise((resolve, reject) => {\n      // if source is a file, just copyFile()\n      // if source is a NOT a glob pattern, simply append **/*\n      const fileRegex = /(\\*|\\{+|\\}+)/g;\n      const matches = fileRegex.exec(command.source);\n\n      if (matches === null) {\n        fs.lstat(command.source, (sErr, sStats) => {\n          if (sErr) return reject(sErr);\n\n          fs.lstat(command.destination, (dErr, dStats) => {\n            if (sStats.isFile()) {\n              const destination =\n                dStats && dStats.isDirectory()\n                  ? command.destination + '/' + path.basename(command.source)\n                  : command.destination;\n\n              if (verbose) {\n                console.log(\n                  `  - FileManagerPlugin: Start copy source: ${command.source} to destination: ${destination}`,\n                );\n              }\n\n              /*\n               * If the supplied destination is a directory copy inside.\n               * If the supplied destination is a directory that does not exist yet create it & copy inside\n               */\n\n              const pathInfo = path.parse(destination);\n\n              const execCopy = (src, dest) => {\n                fsExtra.copy(src, dest, err => {\n                  if (err) reject(err);\n                  resolve();\n                });\n              };\n\n              if (pathInfo.ext === '') {\n                makeDir(destination).then(mPath => {\n                  execCopy(command.source, destination + '/' + path.basename(command.source));\n                });\n              } else {\n                execCopy(command.source, destination);\n              }\n            } else {\n              const sourceDir = command.source + (command.source.substr(-1) !== '/' ? '/' : '') + '**/*';\n              copyDirectory(sourceDir, command.destination, resolve, reject, options);\n            }\n          });\n        });\n      } else {\n        copyDirectory(command.source, command.destination, resolve, reject, options);\n      }\n    });\n}\n\n/**\n * Execute copy directory\n *\n * @param {string} source - source file path\n * @param {string} destination - destination file path\n * @param {Function} resolve - function used to resolve a Promise\n * @param {Function} reject - function used to reject a Promise\n * @return {void}\n */\nfunction copyDirectory(source, destination, resolve, reject, options) {\n  const { verbose } = options;\n\n  /* cpx options */\n  const cpxOptions = {\n    clean: false,\n    includeEmptyDirs: true,\n    update: false,\n  };\n\n  if (verbose) {\n    console.log(`  - FileManagerPlugin: Start copy source file: ${source} to destination file: ${destination}`);\n  }\n\n  cpx.copy(source, destination, cpxOptions, err => {\n    if (err && options.verbose) {\n      console.log('  - FileManagerPlugin: Error - copy failed', err);\n      reject(err);\n    }\n\n    if (verbose) {\n      console.log(`  - FileManagerPlugin: Finished copy source: ${source} to destination: ${destination}`);\n    }\n\n    resolve();\n  });\n}\n\nexport default copyAction;\n","const fs = require('fs');\nconst mv = require('mv');\n\n/**\n * Execute move action\n *\n * @param {Object} command - Command data for given action\n * @return {Function|null} - Function that returns a promise or null\n */\nfunction moveAction(command, options) {\n  const { verbose } = options;\n\n  if (!command.source || !command.destination) {\n    if (verbose) {\n      console.log(\n        '  - FileManagerPlugin: Warning - move parameter has to be formated as follows: { source: <string>, destination: <string> }',\n      );\n    }\n    return null;\n  }\n\n  if (fs.existsSync(command.source)) {\n    return () =>\n      new Promise((resolve, reject) => {\n        if (verbose) {\n          console.log(\n            `  - FileManagerPlugin: Start move source: ${command.source} to destination: ${command.destination}`,\n          );\n        }\n\n        mv(command.source, command.destination, { mkdirp: false }, err => {\n          if (err) {\n            if (verbose) {\n              console.log('  - FileManagerPlugin: Error - move failed', err);\n            }\n            reject(err);\n          }\n\n          if (verbose) {\n            console.log(\n              `  - FileManagerPlugin: Finished move source: ${command.source} to destination: ${command.destination}`,\n            );\n          }\n\n          resolve();\n        });\n      });\n  } else {\n    process.emitWarning('  - FileManagerPlugin: Could not move ' + command.source + ': path does not exist');\n    return null;\n  }\n}\n\nexport default moveAction;\n","const fs = require('fs');\nconst rimraf = require('rimraf');\n\n/**\n * Execute delete action\n *\n * @param {Object} command - Command data for given action\n * @return {Function|null} - Function that returns a promise or null\n */\nfunction deleteAction(command, options) {\n  const { verbose } = options;\n\n  return () =>\n    new Promise((resolve, reject) => {\n      if (verbose) {\n        console.log(`  - FileManagerPlugin: Starting delete path ${command.source}`);\n      }\n\n      if (typeof command.source !== 'string') {\n        if (verbose) {\n          console.log('  - FileManagerPlugin: Warning - delete parameter has to be type of string. Process canceled.');\n        }\n        reject();\n      }\n\n      rimraf(command.source, {}, response => {\n        if (verbose && response === null) {\n          console.log(`  - FileManagerPlugin: Finished delete path ${command.source}`);\n        }\n        resolve();\n      });\n    });\n}\n\nexport default deleteAction;\n","const makeDir = require('make-dir');\n\n/**\n * Execute mkdir action\n *\n * @param {Object} command - Command data for given action\n * @return {Function|null} - Function that returns a promise or null\n */\nfunction mkdirAction(command, options) {\n  const { verbose } = options;\n\n  return () => {\n    if (verbose) {\n      console.log(`  - FileManagerPlugin: Creating path ${command.source}`);\n    }\n\n    if (typeof command.source !== 'string') {\n      if (verbose) {\n        console.log('  - FileManagerPlugin: Warning - mkdir parameter has to be type of string. Process canceled.');\n      }\n      return null;\n    }\n\n    return makeDir(command.source);\n  };\n}\n\nexport default mkdirAction;\n","const fs = require('fs-extra');\nconst path = require('path');\nconst archiver = require('archiver');\n\n/**\n * Execute mkdir action\n *\n * @param {Object} command - Command data for given action\n * @return {Function|null} - Function that returns a promise or null\n */\nfunction archiveAction(command, options) {\n  const { verbose } = options;\n\n  return () =>\n    new Promise((resolve, reject) => {\n      if (!command.source || !command.destination) {\n        if (verbose) {\n          console.log(\n            '  - FileManagerPlugin: Warning - archive parameter has to be formated as follows: { source: <string>, destination: <string> }',\n          );\n        }\n        reject();\n      }\n\n      const fileRegex = /(\\*|\\{+|\\}+)/g;\n      const matches = fileRegex.exec(command.source);\n\n      const isGlob = matches !== null;\n\n      fs.lstat(command.source, (sErr, sStats) => {\n        const output = fs.createWriteStream(command.destination);\n        const archive = archiver(command.format, command.options);\n\n        archive.on('error', err => reject(err));\n        archive.pipe(output);\n\n        // Exclude destination file from archive\n        const destFile = path.basename(command.destination);\n        const globOptions = Object.assign({ ignore: destFile }, command.options.globOptions || {});\n\n        if (isGlob) archive.glob(command.source, globOptions);\n        else if (sStats.isFile()) archive.file(command.source, { name: path.basename(command.source) });\n        else if (sStats.isDirectory())\n          archive.glob('**/*', {\n            cwd: command.source,\n            ignore: destFile,\n          });\n        archive.finalize().then(() => resolve());\n      });\n    });\n}\n\nexport default archiveAction;\n","import { copyAction, moveAction, mkdirAction, archiveAction, deleteAction } from './actions';\n\nclass FileManagerPlugin {\n  constructor(options) {\n    this.options = this.setOptions(options);\n  }\n\n  setOptions(userOptions) {\n    const defaultOptions = {\n      verbose: false,\n      moveWithMkdirp: false,\n      onStart: {},\n      onEnd: {},\n    };\n\n    for (const key in defaultOptions) {\n      if (userOptions.hasOwnProperty(key)) {\n        defaultOptions[key] = userOptions[key];\n      }\n    }\n\n    return defaultOptions;\n  }\n\n  checkOptions(stage) {\n    if (this.options.verbose && Object.keys(this.options[stage]).length) {\n      console.log(`FileManagerPlugin: processing ${stage} event`);\n    }\n\n    let operationList = [];\n\n    if (this.options[stage] && Array.isArray(this.options[stage])) {\n      this.options[stage].map(opts => operationList.push(...this.parseFileOptions(opts, true)));\n    } else {\n      operationList.push(...this.parseFileOptions(this.options[stage]));\n    }\n\n    if (operationList.length) {\n      operationList.reduce((previous, fn) => {\n        return previous.then(retVal => fn(retVal)).catch(err => console.log(err));\n      }, Promise.resolve());\n    }\n  }\n\n  replaceHash(filename) {\n    return filename.replace('[hash]', this.fileHash);\n  }\n\n  processAction(action, params, commandOrder) {\n    const result = action(params, this.options);\n\n    if (result !== null) {\n      commandOrder.push(result);\n    }\n  }\n\n  parseFileOptions(options, preserveOrder = false) {\n    let commandOrder = [];\n\n    Object.keys(options).forEach(actionType => {\n      const actionOptions = options[actionType];\n      let actionParams = null;\n\n      actionOptions.forEach(actionItem => {\n        switch (actionType) {\n          case 'copy':\n            actionParams = Object.assign(\n              { source: this.replaceHash(actionItem.source) },\n              actionItem.destination && { destination: actionItem.destination },\n            );\n\n            this.processAction(copyAction, actionParams, commandOrder);\n\n            break;\n\n          case 'move':\n            actionParams = Object.assign(\n              { source: this.replaceHash(actionItem.source) },\n              actionItem.destination && { destination: actionItem.destination },\n            );\n\n            this.processAction(moveAction, actionParams, commandOrder);\n\n            break;\n\n          case 'delete':\n            if (!Array.isArray(actionOptions) || typeof actionItem !== 'string') {\n              throw Error(`  - FileManagerPlugin: Fail - delete parameters has to be an array of strings`);\n            }\n\n            actionParams = Object.assign({ source: this.replaceHash(actionItem) });\n            this.processAction(deleteAction, actionParams, commandOrder);\n\n            break;\n\n          case 'mkdir':\n            actionParams = { source: this.replaceHash(actionItem) };\n            this.processAction(mkdirAction, actionParams, commandOrder);\n\n            break;\n\n          case 'archive':\n            actionParams = {\n              source: this.replaceHash(actionItem.source),\n              destination: actionItem.destination,\n              format: actionItem.format ? actionItem.format : 'zip',\n              options: actionItem.options ? actionItem.options : { zlib: { level: 9 } },\n            };\n\n            this.processAction(archiveAction, actionParams, commandOrder);\n\n            break;\n\n          default:\n            break;\n        }\n      });\n    });\n\n    return commandOrder;\n  }\n\n  apply(compiler) {\n    const that = this;\n\n    const comp = compilation => {\n      try {\n        that.checkOptions('onStart');\n      } catch (error) {\n        compilation.errors.push(error);\n      }\n    };\n\n    const afterEmit = (compilation, cb) => {\n      that.fileHash = compilation.hash;\n\n      try {\n        that.checkOptions('onEnd');\n      } catch (error) {\n        compilation.errors.push(error);\n      }\n\n      cb();\n    };\n\n    if (compiler.hooks) {\n      compiler.hooks.compilation.tap('compilation', comp);\n      compiler.hooks.afterEmit.tapAsync('afterEmit', afterEmit);\n    } else {\n      compiler.plugin('compilation', comp);\n      compiler.plugin('after-emit', afterEmit);\n    }\n  }\n}\n\nexport default FileManagerPlugin;\n"],"names":["fs","require","path","cpx","fsExtra","makeDir","copyAction","command","options","verbose","source","destination","log","Promise","resolve","reject","fileRegex","matches","exec","lstat","sErr","sStats","dErr","dStats","isFile","isDirectory","basename","pathInfo","parse","execCopy","src","dest","copy","err","ext","then","sourceDir","substr","copyDirectory","cpxOptions","mv","moveAction","existsSync","mkdirp","emitWarning","rimraf","deleteAction","response","mkdirAction","archiver","archiveAction","isGlob","output","createWriteStream","archive","format","on","pipe","destFile","globOptions","Object","assign","ignore","glob","file","name","finalize","FileManagerPlugin","setOptions","userOptions","defaultOptions","key","hasOwnProperty","stage","keys","length","operationList","Array","isArray","map","push","parseFileOptions","opts","reduce","previous","fn","retVal","catch","console","filename","replace","fileHash","action","params","commandOrder","result","forEach","actionOptions","actionType","actionParams","replaceHash","actionItem","processAction","Error","zlib","level","compiler","that","comp","checkOptions","error","errors","afterEmit","compilation","cb","hash","hooks","tap","tapAsync","plugin"],"mappings":"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"}